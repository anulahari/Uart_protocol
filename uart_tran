module uarttrans(
input wire rst,clk,start,parity_enable,
input wire parity_type,
input wire [7:0] tx_data,
output reg tx,
output reg tx_busy);
  parameter CLK_PER_BIT = 16;
    parameter  IDLE      = 3'd0,
               START_BIT = 3'd1,
               DATA_BIT  = 3'd2,
               PARITY    = 3'd3,
               STOP_BIT  = 3'd4;
 reg [13:0] clk_count =0;
reg [2:0] data_ind=0;
reg [7:0] data_reg=0;
reg parity_bit=0;
reg [2:0] state = IDLE;
always @(posedge clk or rst) begin 
if(rst) 
begin 
state <= IDLE;
tx<=1'b1;
clk_count <=0;
tx_busy<=0;
data_ind<=0;
end 
else begin 
case(state)
     IDLE : begin
       tx<=1'b1;
tx_busy<=0;
 if (start) begin 
     data_reg <= tx_data;
     tx_busy <= 1;
     parity_bit <= (parity_type==0) ? ^tx_data : ~^tx_data;
     state <= START_BIT;
     end 
     end       
 START_BIT : begin 
  tx <= 1'b0;
  clk_count <= clk_count + 1;
    if (clk_count == CLK_PER_BIT - 1) begin
                        clk_count <= 0;
                        state <= DATA_BIT;
                        end
                        end 
   DATA_BIT : begin 
   tx <= data_reg[data_ind];
   clk_count <= clk_count + 1;
    if (clk_count == CLK_PER_BIT - 1) begin
                        clk_count <= 0;
                 data_ind <= data_ind +1; 
                 if (data_ind == 3'd7)
    state <= parity_enable ? PARITY : STOP_BIT;
                        end
                        end 
   PARITY : begin 
   tx <= parity_bit;
   clk_count <= clk_count + 1;
   
   if ( clk_count == CLK_PER_BIT-1 )begin
      clk_count<= 0;
      state <= STOP_BIT;
      end 
      end 
   STOP_BIT :begin 
   tx <= 1'b1;
   clk_count <= clk_count + 1;
   if ( clk_count == CLK_PER_BIT-1 )begin
      clk_count<= 0;
      data_ind <= 0;
      state <= IDLE;
      tx_busy <=0;
      end 
      end
      endcase 
      end 
      end 
 endmodule
